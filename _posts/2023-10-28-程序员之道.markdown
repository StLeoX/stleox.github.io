# 编程技艺

## 心法

**将编程技艺置于社交技艺的对立面？**

    引言：[科技爱好者周刊（第 258 期）：卡马克的猫 - 阮一峰的网络日志](https://www.ruanyifeng.com/blog/2023/06/weekly-issue-258.html)

    论点：也许"亲人"和"亲代码"就是有点对立。**性格特别和善可亲的人，往往不容易成为优秀程序员。**

    论据：根据在星环公司观察到的情况，似乎确实如此。程序员除了程序本身，其他一切都不那么在乎，往往能创造更有价值的软件。

    

**提升效能的意识**

    程序员在工作中**要有提升效能的动机**，主要方式包括通过自动化提升工作效率。

    提升效能仍然采用**迭代的基本模式**。

    

**做题家与程序员几乎是对立的思维模式**

    做题家知道，问题的答案是唯一的，所以自己只需要努力找出来“正确答案”即可，目标很明确。

    但是在编程过程中，大到架构设计、小到函数签名的设计，都绝对不是唯一的，我们只是在努力寻找最优解，寻找BugFree的方案。

    这只能是一个不断逼近的过程，所以需要不断地修正目标，甚至会对阶段性的目标完全推倒从来。

    

**写代码就安心地、纯粹地写代码**

    “写完业务写框架”，这对不对？如果在写代码的时候纠结这种问题，是无法安心写代码的。

    在开发的角度，这是对的。这是软件开发过程的事实，软工一条基本原则就是解耦、分离变与不变。这是职业规划方面的事情，而编程本身是纯粹的，只是要满足需求、解决问题。

    在职业规划的角度，可能就有问题了。成功的程序员从来不是只靠编程记忆成功的，例如奥特曼、林纳斯、吴晟。写代码是工作形式和工作过程，职业规划要考虑的方面更多。

    结论是，请将职业规划与工作过程解耦合，工作时就安心地、纯粹地写代码，规划时就认真地做职业规划。

    

**放下对“核心技术”的执念**

    其实随着计算机领域研究经历的增加，我应该逐渐意识到，不存在这样一项技术，能帮助筑起坚实的“技术壁垒”，使他人无法轻易突破，而我只要持有这项技术，**就能保持领先于别人**。所谓“一招鲜吃遍天”。

    这种观点属于“唯技术论”，将技术放在最关键的位置，这种观点是错的。计算机技术的**固有性质就包括学习和传播成本低**，因此根本不存在所谓的“核心技术”和“技术壁垒”，技术总是迭代更新的。

    “技术壁垒”难以筑成是一方面，容易被攻破是另一方面。除开技术因素，还有人的因素。中国人大多且“吃苦耐劳”，且缺少格局，这加速了恶性竞争和内卷的过程。

    认为存在所谓的“核心技术”，这种想法还是学生思维方式，以为自己学好一门课程，分数高就牛逼，在一个领域牛逼就到哪都吃香的喝辣的。先别自嗨，（从第一性原理）好好想一想，有哪个公司愿意为某个领域“单点突破”的程序员买单？都工作了，就别臆想某项技术的“前景”“趋势”了，今天谁给你钱让你干啥你就突破啥呀。

    结论是，要保持持续学习的态度，抛弃一招制胜的观念。

    

**“技术”不该成为“价值”的代名词**

    程序员做研发，多数情况下，重要的**不是技术本身，而是价值**。应该理性地认识到，“技术”不该成为“价值”的代名词，两者是存在差异的，技术的苦和难不等于物质利益。

    程序员做研发，有时是在积累技术、积累经验，但不是在产生价值。

    **在产生价值的事上坚持**，在趋势里去做对的事，和时间做朋友。

    

    执着于技术，只能让你的技术变牛逼，赚不赚不一定。此时能满足市场需求就能赚钱，过段时间风向变了或者这个技术并没有给资本带来那么大的收益，可能就赚不了多少钱。

    要说难的、核心技术的东西，理科搞数学物理理论的不难吗？工科搞电子信息的不难吗？事实上他们只搞本行的话，赚钱就是不如计算机专业，难道计算机专业赚钱多，就是因为计算机专业比他们难吗？

    结论是，如果执着于经济利益，那就应该面向金钱编程。

    结合数据库行业的案例。前两年可能在风口上，但是 24 年风向又变了，因此很多程序员选择撤出这个行业。

    

**从敬业到乐业**

    国外程序员更多是吧编程作为爱好而非工作，这种**融入兴趣到工作**的信仰是值得学习的。

    国外程序员的 programming for playing 和国内程序员的 programming for living，这绝对是 programming 的两个境界。
前者有兴趣因素，一点主要原因是他接触编程较早，在青少年时期就养成了兴趣，就如同绘画之于画家。而国内程序员是在作业、考试、工作等场景下才接触编程的，这种打开方式充满痛苦，与“兴趣”绕道而行。

    

**需要“自我激励”**

    在职业生涯中自我激励，这与程序员的具体职业没有直接联系。

    具体如何自我激励？反问自己：

- 距离职业天花板还有多远？

- 我能进国内一流企业，我能不能进国际一流企业？

- 我能干普通 SDE 工作，我能不能做 TL 或 PL 这些高级工作？

    

**程序员存在天赋差异**

    通过我的观察分析，有人他学编程技术就是有天赋的，像刘yy、周y这样的同学，能把保研和实习这两手都抓好，可能就是有计算机的天赋。

    不同程序员的技能树也不完全重合。有人可能善于艰深技术，就去做研发。有人可能善于讨论交流，就去做产品。还有人喜欢单打独斗，就去做独立开发者。

    

## 方法

### 结对编程

**结对是如何提升效能的**

    两个能力相当的程序员，相互审查代码，往往能收获 1+1>2 的效果。

    

**融入团队**

    结对编程是融入团队的一种方式。

    程序员的生产方式决定了不可能单打独斗，一名伟大的程序员必然是融入在一个伟大的团队当中的。“少有伟大的程序员，只有伟大的团队。”

    

### 摆脱杂活

    摆脱杂活，其目的是转向更高价值工作，并在更高价值工作中谋取自身利益，包括经济利益、自身能力提升等等。

    这些更高价值工作往往是创造型任务，与此相对的是程序型任务。探索型任务比如技术选型，显然对个体的能力要求更高。

    结构上，雇主完成决策和顶层设计，然后下放给雇员去执行。在软件开发领域，组长设计架构，组员编码实现，组长检查组员的工作。结论是选择当组长、做创造型任务。

    

    出于软件开发的固有性质，杂活必然是不可少的。

    谁来做杂活，这是一个立场层面的矛盾，属于结构性矛盾。形象地说，杂活不是你来做就是我来做。

    因此，在处理这个利益、立场层面的矛盾时，**不应该退缩、软弱**，要积极谋取自身利益，这是基本的心态建设。

    

    那么如何摆脱杂活呢？

    第一种方式是，寻求分工的公平性。在预先分工的时候就应该追求公平性。然而，寻求公平性只是下策。

    第二种方式是，将杂活推给别人。既然别人可以将杂活推给我，我也可以将杂活推给别人。

    如果别人将杂活推给我，我首先会明确职责，说明“我这是在帮你”“你这次是欠我的”。

    第三种方式就更加长远、本质了，是通过**提升个人职级**来避免低级的打杂工作。因为更高价值工作往往是给管理者做的，管理者手里的杠杆更大、能撬动的资源更多。

    所以想要摆脱杂活，多想想如何成为管理者，从而安排手下去做杂活。例如，在研究项目中，组长天然地就具有安排组员的权力，正是这种权力让人摆脱杂活。

    

### 迭代

    迭代之于编程、之于产品设计、之于解决方案，都是一种基本的方法论。

    只有通过迭代，才能让程序/产品/方案向预期的方向发展。

    通过编程解决问题的过程，就是迭代解决子问题、最终达到期望状态的过程。

    “迭代”能带来“**一想都是问题，一做起来都是方法**”的过程体验。

    

### 大模型辅助开发

    大模型实际上就是从无穷状态中**构造出了一个初始状态**，让我们能通过提问的方式不断迭代，直到我们期望的结果状态。

    难点在于，可能初始状态就定义在一个局部域上，所以后续迭代都是向着局部解进行的。这也可以说是没有抓住根本问题、主要矛盾。

    利用大模型解决问题，更加需要提炼问题、提炼根本问题的能力。有时候我们看似在解决最终问题，实际上只是在解决子问题而没有解决根问题。

> 参考《提问的智慧》。参考提示词编写指南。

    

**回忆学习法**

    对大模型的会话做**间隔重复记忆**，从而拓展背景知识的边界。这是因为向大模型提出的问题都属于知识缺口。

    间隔重复记忆的要点：多次重复学习材料，但时间间隔逐渐变长；每次回忆时尽量**主动回忆**，而非对照材料被动回忆。

    

**根因分析**

    利用大模型适合从全局分析问题（根因），或者说善于从宏观上理解和把握问题。这是因为大模型掌握的**背景知识是足够充分的**，能避免陷入局部最优解。

    

**提示生成代码**

    程序可以划分为即抛型程序和稳定型程序，llm 辅助编程更适用于前者，例如写一段 bash 完成某个 ad hoc 的文本处理需求。

    

### 代码审查

    代码审查的一些基本态度，来自于我的生产实践：

- 求同存异。求大同存小异是审查时的最基本态度，因为每个人的编码风格、设计思路乃至对问题的理解都存在差异，这也客观决定了项目是所有参与者的风格的整合，总会有程序员拉低平均水平的。

- 对事不对人。有人做不好我指派的任务，或者完成情况不能令我满意，是人的办事能力有问题，不是人有问题。这种情况下换人、换更有经验的程序员是一种有效方式。

    

### 设计模式

**控制反转**

    控制反转是设计模式的一个目标。直观理解“控制反转”的概念：控制即是控制结构与函数入口，反转即是使用（转到）这些控制的方式。

    

### 代码重构

    对代码有强迫症是好的，这就引入了代码重构的动力。好的代码就像好的身材一样，没有一丝赘肉。

    

# 参考

[Fitten Code vs Copilot](https://mp.weixin.qq.com/s/gJP94KbiwBKRqSwdx5jqSA)

[如何摆脱打杂状态，从事更高价值工作](https://mp.weixin.qq.com/s/AZ5HJusQ31GPK-IgwIFoyQ)
