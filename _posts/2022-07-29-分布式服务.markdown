## why distributed service architecture

    服务访问的**并发度**对软件架构往往有决定性的作用。

> 举个栗子，单线程访问的**客户端**（比如单机游戏某时刻往往仅有一名用户作为输入）不需要考虑并发访问的问题；多线程、高并发访问的 DBMS 就需要考虑，并为此建立了ACID事务模型，尤其关注隔离性；多线程、超高并发访问的**流量入口网关**，还需要结合网络协议、Linux 内核等进行特定的调优。
> 
> 只要存在高并发，就存在 scale-out 的架构需求。

## stateful service VS. stateless service

### stateful service

- 服务本身依赖或者存在局部的状态数据，这些数据需要自身持久化或者可以通过其他节点恢复。
- 一个请求只能被某个节点（或者同等状态下的节点）处理。
- 存储状态数据，实例的拓展需要整个系统参与状态的迁移。
- 在一个封闭的系统中，存在多个数据闭环，需要考虑这些闭环的数据一致性问题。
- 通常存在于分布式架构中。

### stateless service

- 服务不依赖自身的状态，实例的状态数据可以维护在内存中。
- 任何一个请求都可以被任意一个实例处理。
- 不存储状态数据，实例可以水平拓展，通过负载均衡将请求分发到各个节点。
- 在一个封闭的系统中，只存在一个数据闭环。
- 通常存在于单体架构的集群中。

### comparison

    **从数据层面看状态**，数据的状态往往受2个维度有关，一是与时间相关或者顺序相关的，不同的操作顺序可能导致同一个时间点上的数据状态大于1个，二是与数据的副本状态相关的。也就是数据的位置，数据落在多个副本上，可能出现多种数据状态的组合。

    **从服务层面看**，服务层面的状态取决于实例是单独维护数据还是共享数据，或者说是否存在多个数据闭环让数据的流向产生了多条路径。有状态的服务往往比较难进行水平拓展，在现在容器盛行的环境，把服务设计成无状态的更加高效，即便是有状态的服务，也要将状态内敛在系统的某个范围，比如分布式的存储，对于业务服务，我不需要关心数据在多个副本的状态，数据的状态由分布式存储这个服务本身解决。

> from： [有状态服务和无状态服务 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/347379130)

### Immutable Infrastructure

> ref: [什么是不可变的基础设施？](https://cloud.tencent.com/developer/article/1358628)

​    不可变基础设施的构想是对无状态服务的延伸。

​    不可变基础设施（Immutable Infrastructure）是由 Chad Fowler 于 2013 年提出的一个很有前瞻性的构想：在这种模式中，任何基础设施的实例（包括服务器、容器等各种软硬件）一旦创建之后便成为一种只读状态，不可对其进行任何更改。如果需要修改或升级某些实例，唯一的方式就是创建一批新的实例以替换。这种思想与不可变对象的概念是完全相同的。

​    实现这种模式的好处是显而易见的，这意味着配置工作可实现重复性，减少了配置管理工作的负担，让持续集成与持续部署过程变得更流畅。同时它也更易于应对部署环境间的差异及版本管理，包括在部署出错时可进行快速回滚 —— 只要旧版本的镜像文件还有备份，就可以快速地生成旧版本的实例进行替换。否则的话，就只能老老实实地重新构建旧版本的实例，并且祈祷能够赶在老板掀桌之前完成回滚。

​    实现这一模式需要满足两点基本需求，首先应用程序必须是**无状态的**，不可依赖于本地的文件上传、会话与缓存。基本上，如果应用程序要实现负载均衡，都必须满足这一点。而更重要的一点是，能够通过某种_ 模板_（或指令）将实例快速地部署到生产环境中。后一点无疑是关键所在，也是这一模式的最大挑战。

​    虽然这种模式能够带来很大的好处，但实现它的难度也是很高的，传统的虚拟化技术在应对这一模式时显得有些力不从心。幸运的是，DevOps 社区发现Docker（或者说容器）正是实现这一模式的优秀选择。
