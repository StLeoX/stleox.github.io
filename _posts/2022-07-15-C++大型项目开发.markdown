## 依赖管理

### 依赖管理工具

​    C++ 语言本身有依赖管理工具吗？无。

​    C++ 的依赖管理是交给 Apt/Yum 和 CMake 代理的。

### 依赖版本管理

    依赖管理的核心问题是依赖的版本管理。这个问题与语言无关，只要是全局的（sharing dependencies between apps），就需要解决这个问题，不论是还是 `pip` 还是 `apt`。

1. 最新的未必是最好的，**稳定兼容**的才是最好的

    一般而言，在版本管理中存在以下两类问题，以 `pip` 为例。

- 依赖版本过高：当前依赖舍弃了某个API，但是App还在用；或是修改了某个API，但是App在用旧版API；

- 依赖版本过低：当前依赖还不存在某个API，但是App已经用上了更新的API（最新版依赖确实提供该API）；

    针对依赖版本过高/低的问题当然是限制其最高/低版本。一般而言，需要对两者都进行限制。不幸的是，针对全局依赖，很显然的在不同App中的限制区间可能不相交。

    所以我们约定，开发者应该持续升级自己的App，使其跟随最新版依赖的API。

    还有一个问题是，为什么不能**同时缓存多个版本的依赖**？这样我们在使用时显式指定即可。原因不清楚，但是没见过全局的管理工具是这样做的。

## 配置管理

​    实在是无法理解，为什么 C++ 项目的配置还需要写在 shell 脚本、以环境变量的形式，这种对可执行文件的古老的调用方式，应该只停留在上一世纪。

    现代化的做法是专门的配置文件，如 `yaml` , `json`。

## 经验之谈

### C++ 项目设计原则

1. 三思而后行

> Think twice, code once.

2. 惰性地添加新特性

> Delay adding new features until it is clear how the new features will be used.  
> 
> -- From *Google BigTable Design*

    不必急于添加新特性，而应该先明确新需求。因为特性是跟随需求变化的。

3. 软件要素分析法

    软件需求的要素分析法：软件要素就像是题目的**题眼**。架构、细节、开发过程一定是围绕要素展开的，就像一个题目是要求长度那首先肯定不会关心角度。抓住软件要素，每次重构升级都围绕要素展开，才能以高效的方式进行开发。

    要素主要是指**核心的数据字段**，围绕要素开发是指主要关心这些字段是如何在函数、对象、组件之间**传播**、剪裁、填充等的。

### C++ 项目开发原则

1. “站在编译器的肩膀上开发”

    C++ 比 C 要好的一点是，**能将错误尽量地在编译期暴露出来，而不留到运行时**。

    所以要善于观察 CC 的报错信息，虽然往往不太友好。

### C++ 开发者心态

1. 学霸两支笔，差生文具多

    举个例子，大佬写C都是把符号记在脑子里面的，编辑器只是辅助。

    所以有个说法是，写代码时的脑部活动和做**阅读理解**时的是相似的，因为都要缓存大量的**上下文**以进行推理。做阅读时缓存的可能是文学上的知识，写代码时缓存的内容应该和**注释**比较相似，包括模块的调用方法、注意事项等。同时还包括倒排的关联关系，包括“什么功能写在哪里”等。

    

# 参考

做 C++ 开发时看得一些比较重要的教程：

- 深度探索C++对象模型

- C++ Concurrency in Action 2nd

- C++ Templates 2nd

- C++17 the Complete Guide

- C++17 in Detail

- 现代C++语言核心特性解析

- The Art of Writing Efficient Programs

- Professional CMake